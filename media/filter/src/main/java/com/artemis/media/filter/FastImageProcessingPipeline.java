package com.artemis.media.filter;import android.opengl.GLSurfaceView.Renderer;import com.artemis.media.filter.GLRenderer;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Queue;import javax.microedition.khronos.egl.EGLConfig;import javax.microedition.khronos.opengles.GL10;/** * Filter pipeline renderer implementation of the GLSurfaceView.Renderer.  In addition to the GLSurfaceView.Renderer methods, * this class provides methods for processing the given graph of filters.  This graph of filters can be set by creating one * or more filter graphs and then passing the root of the graphs to this class using addRootRenderer(GLRenderer rootRenderer). * This class will not start processing the filters until startRendering() has been called.  Once it has started rendering, * the filter graph should not be changed without first calling pauseRendering().  Although this is theoretically not required, * it is recommended.  If a filter is removed from the processing pipeline, addFilterToDestroy(GLRenderer filter) should be called * to clean up opengl memory. * * @author Chris Batt */public class FastImageProcessingPipeline implements Renderer {    private boolean rendering;    private List<GLRenderer> rootRenderers;    private List<GLRenderer> filtersToDestroy;    private int width;    private int height;    private final Queue<Runnable> mRunOnDraw;    private final Queue<Runnable> mRunOnDrawEnd;    /**     * Creates a FastImageProcessingPipeline with the initial state as paused and having no rootRenderer.     */    public FastImageProcessingPipeline() {        rendering = false;        filtersToDestroy = new ArrayList<GLRenderer>();        rootRenderers = new ArrayList<GLRenderer>();        mRunOnDraw = new LinkedList<Runnable>();        mRunOnDrawEnd = new LinkedList<Runnable>();    }    protected void runOnDraw(final Runnable runnable) {        synchronized (mRunOnDraw) {            mRunOnDraw.add(runnable);        }    }    protected void runOnDrawEnd(final Runnable runnable) {        synchronized (mRunOnDrawEnd) {            mRunOnDrawEnd.add(runnable);        }    }    private void runAll(Queue<Runnable> queue) {        synchronized (queue) {            while (!queue.isEmpty()) {                queue.poll().run();            }        }    }    /**     * Adds a given filter to the list of filters to have its resources removed next time this pipeline     * receives an opengl context.  The filter will still be usable and will recreate all of the destroyed     * opengl objects next time it is used in the pipeline.     *     * @param renderer     */    public void addFilterToDestroy(final GLRenderer renderer) {        runOnDraw(new Runnable() {            @Override            public void run() {                filtersToDestroy.add(renderer);            }        });    }    /**     * Adds a root node of graph of filters that the pipeline will process and draw to the given endpoints of the graph.     *     * @param rootRenderer A root node (input node) of the graph of filters and endpoints.     */    public synchronized void addRootRenderer(final GLRenderer rootRenderer) {        rootRenderers.add(rootRenderer);    }    /**     * Returns the height of GLSurfaceView on the screen.     *     * @return height     */    public int getHeight() {        return height;    }    /**     * Returns the width of GLSurfaceView on the screen.     *     * @return width     */    public int getWidth() {        return width;    }    private synchronized boolean isRendering() {        return rendering;    }    /* (non-Javadoc)     * @see android.opengl.GLSurfaceView.Renderer#onDrawFrame(javax.microedition.khronos.opengles.GL10)     */    @Override    public void onDrawFrame(GL10 unused) {        runAll(mRunOnDraw);        if (isRendering()) {            for (int i = 0; i < rootRenderers.size(); i++) {                GLRenderer rootRenderer;                synchronized (this) {                    rootRenderer = rootRenderers.get(i);                }                rootRenderer.onDrawFrame();            }        }        synchronized (filtersToDestroy) {            for (GLRenderer renderer : filtersToDestroy) {                renderer.destroy();            }            filtersToDestroy.clear();        }        runAll(mRunOnDrawEnd);    }    /* (non-Javadoc)     * @see android.opengl.GLSurfaceView.Renderer#onSurfaceChanged(javax.microedition.khronos.opengles.GL10, int, int)     */    @Override    public void onSurfaceChanged(GL10 unused, int width, int height) {        this.width = width;        this.height = height;    }    /* (non-Javadoc)     * @see android.opengl.GLSurfaceView.Renderer#onSurfaceCreated(javax.microedition.khronos.opengles.GL10, javax.microedition.khronos.egl.EGLConfig)     */    @Override    public void onSurfaceCreated(GL10 unused, EGLConfig config) {    }    /**     * Pauses the rendering of the graph. This method should be called before the alteration of the filter graph; however,     * altering the filter graph without pauses should still work.     */    public synchronized void pauseRendering() {        rendering = false;    }    /**     * Removes a root node of graph of filters that the pipeline will process and draw to the given endpoints of the graph.     *     * @param rootRenderer A root node (input node) of the graph of filters and endpoints.     */    public synchronized void removeRootRenderer(GLRenderer rootRenderer) {        rootRenderers.remove(rootRenderer);    }    /**     * Starts the rendering of the graph. If this is called before a root node renderer has been     * added, it will do nothing.     */    public synchronized void startRendering() {        if (rootRenderers.size() != 0) {            rendering = true;        }    }    public void destroy() {        runOnDrawEnd(new Runnable() {            @Override            public void run() {                for (GLRenderer renderer : rootRenderers) {                    renderer.destroy();                }                rootRenderers.clear();                for (GLRenderer renderer : filtersToDestroy) {                    renderer.destroy();                }                filtersToDestroy.clear();            }        });    }    public void destroyIndeed(){        for (GLRenderer renderer : rootRenderers) {            renderer.destroy();        }        rootRenderers.clear();        for (GLRenderer renderer : filtersToDestroy) {            renderer.destroy();        }        filtersToDestroy.clear();    }}